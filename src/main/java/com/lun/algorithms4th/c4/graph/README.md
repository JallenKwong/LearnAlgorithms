**图的典型利用**

应用|结点|连接
---|---
地图|十字路口|公路
网络内容|网页|超链接
电路|元器件|导线
任务调度|任务|限制条件
商业交易|客户|交易
配对|学生|申请
计算机网络|网站|物理连接
软件|方法|调用关系
社交网络|人|友谊关系

无向图
---

边edge仅仅是两个顶点vertex之间的连接

**图由 一组顶点和 一组能够将两个顶点相连的边 组成的**

一般使用0~V-1来表示一张含有V个顶点的图中的各个顶点，这样方便使用数组索引访问各个顶点中信息。

![](image/graph.png)

### 术语glossary ###

1. **自环**，即一条连接一个顶点和其自身的边；
2. 连接同一对顶点的两条边称为**平行边**；
3. 当两个顶点通过一条边相连时，我们成这连个顶点是**相邻的adjacent**，并称这条边**依附于incident**这两个顶点；
4. 某个顶点的**度数**为依附它的边的总数；
5. **子图**是由一幅图的所有边的一个子集（以及他们所依附的所有顶点）组成的图；
6. **路径**是由 边 顺序连接的一系列顶点。**简单路径**是一条没有 重复 顶点 的路径；
7. **环**是一条至少含有一条边 且 起点和终点相同 的路径，**简单环**是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环；
8. 路径或者环的**长度**为其中所包含的边数；
9. 当两个顶点之间存在一条连接双方路径时，我们称一个顶点和另一个顶点是**连通**的；
10. 如果从任意一个顶点都存在一条路径到大另一个任意顶点，我们称这幅图是**连通图**。一幅**非连通的图**由若干个连通的部分组成，它们都是其极大连通子图；
11. **无环图**是一种不包含环的图；
12. **树**是一幅无环连通子图，互不相连的树组成的集合称为**森林**；
13. 连通图的**生成树**是它的一幅子图，它含有图中的所有顶点且是一棵树。图的**生成树森林**是它的所有连通子图的生成树集合；
14. **二分图**是一种能够将所有结点分为两部分的图，其中图的每条边所连接的连个顶点都分为属于不同的部分。(二分图例子：电影和演员)
15. 图的**密度**是指已经连接的顶点对占所有可能被连接的顶点对的比例。(稠密、稀疏)

![](image/bipartite-graph.png)

上图为二分图的实例，其中红色的结点是一个集合，黑色的结点是另一个集合

![](image/graph-anatomy.png)![](image/tree.png)![](image/forest.png)

### 表示无向图的数据类型 ###

可以表示图的数据结构

1. 邻接矩阵
2. 边的数组
3. 邻接表数组（Bag）(我们使用这个数据结构)
4. 邻接集数组（SET）

**典型Graph实现的性能复杂度**

数据结构|所需时间|添加一条边v-w|检查w和v是否相邻|遍历v的所有相邻顶点
---|
边的数组|E|1|E|E
邻接矩阵|V^2|1|1|V
邻接表|E+V|1|degree(V)|degree(V)
邻接集|E+V|logV|logV|logV+degree(v)

---

[Graph数据类型代码](Graph.java)

---

准备数据

**tinyG.txt**

	13
	13
	0 5
	4 3
	0 1
	9 12
	6 4
	5 4
	0 2
	11 12
	9 10
	0 6
	7 8
	9 11
	5 3

该文件表示图为

![](image/tinyG.png)

连接表图示为

![](image/adjacency-lists.png)

---

[Graph](Graph.java) 运行结果

	13 vertices, 13 edges 
	0: 6 2 1 5 
	1: 0 
	2: 0 
	3: 5 4 
	4: 5 6 3 
	5: 3 4 0 
	6: 0 4 
	7: 8 
	8: 7 
	9: 11 10 12 
	10: 9 
	11: 9 12 
	12: 11 9 

[其他常用图处理代码GraphClient](GraphClient.java)

注意：多个不同的邻接表可能表示着同一幅图。

**理解算法的最好方法是在一个简单的例子中跟踪它的行为。**

### 深度优先搜索DFS(DepthFirstSearch) ###

DFS的基本思想

要搜索一幅图，只需用一个递归方法来**遍历所有顶点。**

在访问其中一个顶点时：

- 将它标记为已访问
- 递归地访问它的所有没有被标记过的邻居顶点

如果图是连通的，每个邻接链表中的元素都会被检查到

**命题A 深度优先搜索标记与起点连通的所有顶点 所需的时间t 和 顶点的度数之和sumOfDegree 成正比**

[深度优先搜索DFS](DepthFirstSearch.java)

---

输入参数：tinyG.txt(请查看上文) 0(顶点)

输出结果：

	0 1 2 3 4 5 6 
	NOT connected

---

输入参数：tinyCG.txt 0(顶点)

	6
	8
	0 5
	2 4
	2 3
	1 2
	0 1
	3 4
	3 5
	0 2

![](image/tinyCG.png)

输出结果：

	0 1 2 3 4 5 
	connected

使用深度优先搜索的轨迹，寻找所有和顶点0连通的顶点：

![](image/traceOfDfs.png)

### 寻找路径（如是否存在从s到v的路径）（使用DFS思想） ###

[使用深度优先搜索查找图中的路径DepthFirstPaths](DepthFirstPaths.java)

输入tinyCG.txt 0（起点）

输出结果：

	0 to 0:  0
	0 to 1:  0-2-1
	0 to 2:  0-2
	0 to 3:  0-2-3
	0 to 4:  0-2-3-4
	0 to 5:  0-2-3-5

![](image/traceOfPathTo5Computation.png)

**命题A(续)。使用深度优先搜索得到 从给定起点到任意标记顶点的路径所需的时间t 与 路径的长度L 成正比**

### 广度优先搜索BFS(BreadthFirstPath) ###

能解决的问题

单点最短路劲。给定一幅图和一个起点是s,回答“从s到给定目的顶点v是否存在一条路径？如果有，找出其中最短的那条（所含边数最少）”等类似问题。

类比：

- 深度优先搜索就好像是一个人在走迷宫，(Tremaux搜索)a.选择一条么有标记过的通路，在你走过的路上铺一条绳子;b.标记所有你第一次路过的路口和通道;c.当来到一个标记过的路口时（用绳子）回退到上一个路口；d.当回退到的路口已没有可走的通道时继续回退
- 广度优先搜索则好像一组人在一起朝各个方向走这座迷宫，每个人都有自己的绳子。当出现新的叉路时，可以假设一个探索者可以分裂为更多的人来搜索它们，当两个探索者相遇时，会合二为一（并继续使用先到达者的绳子）

---

[使用广度优先搜索查找图中路径BreadthFirstPaths](BreadthFirstPaths.java)

---

输入：tinyCG.txt 0（起点）

输出结果：

	0 to 0 (0):  0
	0 to 1 (1):  0-1
	0 to 2 (1):  0-2
	0 to 3 (2):  0-2-3
	0 to 4 (2):  0-2-4
	0 to 5 (1):  0-5

轨迹图

![](image/traceOfBfs.png)

**命题B。对于从s可达的任意顶点v,广度优先搜索都能够找到一条从s到v的最短路径（没有其他从s到v的路径所含的边比这条路径更少）**

**命题B（序）。广度优先搜索所需的时间在最好坏情况下和V+E成正比**

### DFS和BFS总结 ###

在搜索中我们都会先将起点存入数据结构中，然后重复以下步骤知道数据结构被清空：

- 取其中的下一个顶点并标记它
- 将v的所有相邻而又被标记的顶点加入数据结构

不同之处仅在于 从数据结构中获取下一个顶点规则

DFS|BFS
---|
晚加入的顶点|早加入的顶点
不断深入图中并在栈Stack中保存所有分叉的顶点|像扇面一般扫描图，用一个队列Queue保存访问过的最前端的顶点
探索一幅图的方式是寻找离起点更远的顶点，只在碰到死胡同时才访问近处的顶点|首先覆盖起点附近的顶点，只在邻近的所有顶点都被访问了之后才向前前进
路径通常较长而且曲折|路径则短而直接

![](image/dfsAndBfs.png)

### 连通分量 ###

找出一幅图所有的连通分量（一个顶点组之间的任意两点能相互连通，就算一个连通）

[使用深度优先搜索找出图中的所有连通分量](ConnectedComponents.java)

![](image/cc.png)

**环**是一条至少含有一条且起点和终点相同的路径。

其他示例：

[G是不是无环图](Cycle.java)：另外检测有没有自环或平行边

[G是不是符号图](Bipartite.java)

### 符号图SymbolGraph ###

在典型应用中，图都是通过文件或者网页定义的，使用的是字符串而非整数来表示和指代顶点。

准备数据

![](image/routes.png)

需要用到的数据结构

![](image/symbol-graph.png)

[符号图SymbolGraph实现源码](SymbolGraph.java)

---

**间隔的度数**

图处理的一个经典问题就是，找到一个社交网络之中两人间隔的度数。


两个顶点之间需要找到**最短**长度，需要用到BreadthFirstPaths BFS

**命题B。对于从s可达的任意顶点v,广度优先搜索都能够找到一条从s到v的最短路径（没有其他从s到v的路径所含的边比这条路径更少）**

综合SymbolGraph和BFS来解决间隔的度数问题

[间隔的度数](DegreesOfSeparation.java)

**小结**

得到解决的无向图处理问题

问题|解决方法
---|---
单点连通性|[DFS](DepthFirstSearch.java)
单点路径|[DepthFirstPaths](DepthFirstPaths.java)
单点最短路径|[BreadthFirstPaths](BreadthFirstPaths.java)
连通性|[ConnectedComponents](ConnectedComponents.java)
检测环|[Cycle](Cycle.java)
双色问题(图的二分性)|[Bipartite](Bipartite.java)


