# B-树 学习笔记 #

平衡树算法的扩展。

它支持对保存在磁盘或者网络上的符号表进行**外部查找**。

令人惊讶的是，这算法只需使用4~5个指向一小块数据的引用即可有效支持在含有数百亿或者更多元素的符号表中进行查找。

### 成本模型 ###

**页Page**表示一块连续的数据，如 一个文件 或 4096字节块chunk。

**探查Probe**表示访问一个页， 如 从 硬盘 到 内存。

**目标**实现能够仅用极少次数的探查即可找到任意给定键的查找算法。

**成本模型**使用页的访问次数（无论读写）作为外部查找算法的成本模型。

**B-树**

像2-3树那样，限制了每个结点“键-链接”对的上下数量界限。

选择一个**参数M**（一般都是一个偶数）并构造一棵多向树，

每个结点**最多含有M-1对键和链接**（假设M足够小，使得每个M向结点都能够存放在一个页中，如M=1024），

**最少含有M/2对键和链接**（以提供足够多的分支来保证查找路径），

也就是节点键和链接的对数在**(M/2, M-1)**区间。

<span style='color:red;'>根节点是个例外，它含有小于M/2对键和链接，但也不能少于2对。(2, M/2)</span>

**内部结点**：含有与页相关联的键的副本。

**外部结点**：含有指向实际数据的引用

![](image/B-tree-example.png)

**哨兵键**小于其他所有键

### 查找 ###

![](image/B-tree-search.png)

### 插入 ###

![](image/B-tree-insert.png)

### 删除 ###

TODO:

### 源码 ###

[B-Tree](BTree.java)

### 性能 ###

>含有N个元素的M阶B-树中的一次查找或插入操作需要logN/logM ~ logN/log(M/2)次探查(如：M = 1024; N = 62 billion ，logN/log(M/2) ≤ 4)

---

>优化.总是将根节点保存在内存中。


### 应用 ###

B-树及它的变种(B+树,B*树等)广泛应用于 数据库 和 文件系统。

一棵大B-树。

![](image/large-B-tree.png)

### 引用 ###

1.《算法4th》Robert Sedgewick & Kevin Wayne 著 ，谢路云 译

[2.BTree.java](https://algs4.cs.princeton.edu/62btree/BTree.java.html) 